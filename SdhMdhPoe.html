import React, { useState, useEffect, useRef } from 'react';
import { Layers, RefreshCw, Activity, ArrowRightLeft, Move3d } from 'lucide-react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ----------------------------------------------------------------------
// 1. Math & Kinematics Constants
// ----------------------------------------------------------------------

const LINK_LENGTHS = {
  L1: 2,
  L2: 2,
  L3: 1.5
};

// Helper: Round numbers for display
const f = (num) => {
  if (Math.abs(num) < 0.0001) return '0.00';
  return num.toFixed(2);
};

// Helper: Format Matrix4 to HTML grid
const MatrixDisplay = ({ matrix, label }) => {
  const elements = matrix.elements; 
  const rows = [
    [elements[0], elements[4], elements[8], elements[12]],
    [elements[1], elements[5], elements[9], elements[13]],
    [elements[2], elements[6], elements[10], elements[14]],
    [elements[3], elements[7], elements[11], elements[15]],
  ];

  return (
    <div className="mb-4 bg-white p-2 rounded border border-slate-200 shadow-sm">
      <div className="text-xs font-bold text-slate-600 mb-1">{label}</div>
      <div className="grid grid-cols-4 gap-x-2 gap-y-1 font-mono text-[10px] text-slate-800">
        {rows.map((row, r) => (
          row.map((val, c) => (
            <div key={`${r}-${c}`} className="text-right whitespace-nowrap">
              {f(val)}
            </div>
          ))
        ))}
      </div>
    </div>
  );
};

// Helper: Display Screw Axis
const ScrewDisplay = ({ label, omega, v, theta }) => (
  <div className="mb-3 bg-white p-2 rounded border border-slate-200 shadow-sm text-xs">
    <div className="flex justify-between items-center mb-1">
        <span className="font-bold text-slate-700">{label}</span>
        <span className="text-blue-600 font-mono">θ = {f(theta)} rad</span>
    </div>
    <div className="font-mono text-[10px] grid grid-cols-2 gap-2 text-slate-600">
      <div>ω: [{f(omega.x)}, {f(omega.y)}, {f(omega.z)}]</div>
      <div>v: [{f(v.x)}, {f(v.y)}, {f(v.z)}]</div>
    </div>
  </div>
);

// ----------------------------------------------------------------------
// 2. React Components
// ----------------------------------------------------------------------

const App = () => {
  const [activeTab, setActiveTab] = useState('intro');
  const [jointAngles, setJointAngles] = useState({ j1: 0, j2: 0, j3: 0 });
  const [visMode, setVisMode] = useState('MDH'); // 'MDH' | 'SDH' | 'NONE'
  const [isRobotReady, setIsRobotReady] = useState(false);
  
  // Real-time Kinematics Data State
  const [kinematicsData, setKinematicsData] = useState({
    matrices: [],
    endEffector: { pos: new THREE.Vector3(), rot: new THREE.Euler() },
    poeScrews: []
  });

  // Refs for 3D Scene
  const mountRef = useRef(null);
  const sceneRef = useRef(null);
  const robotRef = useRef(null);
  const framesRef = useRef([]);
  const screwsRef = useRef([]); // To store PoE arrow helpers

  // --- 3D Scene Initialization ---
  useEffect(() => {
    if (!mountRef.current) return;

    // Scene Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf8fafc); // Slate-50
    scene.fog = new THREE.Fog(0xf8fafc, 10, 50);
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(45, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 100);
    camera.position.set(7, 5, 7);
    camera.lookAt(0, 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    renderer.shadowMap.enabled = true;
    mountRef.current.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Grid & Ground
    const gridHelper = new THREE.GridHelper(20, 20, 0xcbd5e1, 0xe2e8f0);
    scene.add(gridHelper);

    // Robot Construction
    const robotGroup = new THREE.Group();
    scene.add(robotGroup);
    
    // Materials (Transparent)
    const matBase = new THREE.MeshStandardMaterial({ 
      color: 0x475569,
      roughness: 0.5,
      metalness: 0.5
    });
    const matLink = new THREE.MeshStandardMaterial({ 
      color: 0x3b82f6, 
      transparent: true, 
      opacity: 0.5,
      roughness: 0.2,
      metalness: 0.1,
      side: THREE.DoubleSide 
    });
    const matJoint = new THREE.MeshStandardMaterial({ 
      color: 0xeab308, 
      transparent: true, 
      opacity: 0.6,
      roughness: 0.2,
      metalness: 0.1
    });

    // --- Robot Parts ---
    // Base
    const baseGeo = new THREE.CylinderGeometry(0.8, 1, 0.5, 32);
    const baseMesh = new THREE.Mesh(baseGeo, matBase);
    baseMesh.position.y = 0.25;
    robotGroup.add(baseMesh);

    // Link 1 Group (J1 Axis: Y) - Note: In Three.js Y is Up. 
    const link1Group = new THREE.Group();
    link1Group.position.y = 0.5; // Joint 1 origin
    robotGroup.add(link1Group);

    // Link 1 Geometry
    const l1Mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, LINK_LENGTHS.L1, 0.5), matLink);
    l1Mesh.position.y = LINK_LENGTHS.L1 / 2;
    link1Group.add(l1Mesh);
    
    // Joint 2 visual
    const j2Mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6), matJoint);
    j2Mesh.position.y = LINK_LENGTHS.L1;
    link1Group.add(j2Mesh);

    // Link 2 Group (J2 Axis: Z)
    const link2Group = new THREE.Group();
    link2Group.position.y = LINK_LENGTHS.L1;
    link1Group.add(link2Group);

    // Link 2 Geometry
    const l2Mesh = new THREE.Mesh(new THREE.BoxGeometry(LINK_LENGTHS.L2, 0.4, 0.4), matLink);
    l2Mesh.position.x = LINK_LENGTHS.L2 / 2;
    link2Group.add(l2Mesh);

    // Joint 3 visual
    const j3Mesh = new THREE.Mesh(new THREE.SphereGeometry(0.5), matJoint);
    j3Mesh.position.x = LINK_LENGTHS.L2;
    link2Group.add(j3Mesh);

    // Link 3 Group (J3 Axis: X)
    const link3Group = new THREE.Group();
    link3Group.position.x = LINK_LENGTHS.L2;
    link2Group.add(link3Group);

    // Link 3 Geometry
    const l3Mesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, LINK_LENGTHS.L3, 0.3), matLink);
    l3Mesh.position.y = LINK_LENGTHS.L3 / 2; 
    link3Group.add(l3Mesh);

    // End Effector
    const eeMesh = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0xff4444, transparent: true, opacity: 0.8 }));
    eeMesh.position.y = LINK_LENGTHS.L3;
    link3Group.add(eeMesh);

    // Save refs
    robotRef.current = { link1: link1Group, link2: link2Group, link3: link3Group, ee: eeMesh };
    setIsRobotReady(true);

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      if (!mountRef.current) return;
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (mountRef.current) mountRef.current.removeChild(renderer.domElement);
      setIsRobotReady(false);
    };
  }, []);

  // --- Update Joint Angles & Kinematics Calculations ---
  useEffect(() => {
    if (!isRobotReady || !robotRef.current) return;
    const { link1, link2, link3, ee } = robotRef.current;
    
    // Apply Rotations
    link1.rotation.y = jointAngles.j1; 
    link2.rotation.z = jointAngles.j2; 
    link3.rotation.x = jointAngles.j3; 

    // Force update of matrices to get accurate world positions
    link1.updateMatrixWorld(true);

    // --- Calculate Real-time Kinematics Data ---
    
    // 1. End Effector State (World Frame)
    const eeWorldPos = new THREE.Vector3();
    const eeWorldQuat = new THREE.Quaternion();
    ee.getWorldPosition(eeWorldPos);
    ee.getWorldQuaternion(eeWorldQuat);
    const eeEuler = new THREE.Euler().setFromQuaternion(eeWorldQuat);
    
    // 2. Matrices Calculation
    const matrices = [];
    if (visMode === 'MDH' || visMode === 'SDH') {
        if (framesRef.current && framesRef.current.length >= 4) {
             const frames = framesRef.current.filter(o => o.type === 'AxesHelper');
             if (frames.length >= 4) {
                frames.forEach(f => f.updateMatrixWorld(true));
                for (let i = 1; i < frames.length; i++) {
                    const prevFrame = frames[i-1];
                    const currFrame = frames[i];
                    const mat = new THREE.Matrix4().copy(prevFrame.matrixWorld).invert().multiply(currFrame.matrixWorld);
                    matrices.push({ name: `T${i-1}${i}`, data: mat });
                }
                const totalMat = new THREE.Matrix4().copy(frames[0].matrixWorld).invert().multiply(frames[frames.length-1].matrixWorld);
                matrices.push({ name: `T_Total (0->3)`, data: totalMat });
             }
        }
    }

    // 3. PoE Screws (Analytical - World Frame Zero Config)
    const baseOffset = 0.5;
    
    const screws = [
        { label: 'S1 (Base)', omega: {x:0, y:1, z:0}, v: {x:0, y:0, z:0}, theta: jointAngles.j1 },
        { label: 'S2 (Shoulder)', omega: {x:0, y:0, z:1}, v: {x:baseOffset + LINK_LENGTHS.L1, y:0, z:0}, theta: jointAngles.j2 }, 
        { label: 'S3 (Elbow)', omega: {x:1, y:0, z:0}, v: {x:0, y:baseOffset + LINK_LENGTHS.L1, z:-LINK_LENGTHS.L2}, theta: jointAngles.j3 } 
    ];

    setKinematicsData({
        matrices,
        endEffector: { pos: eeWorldPos, rot: eeEuler },
        poeScrews: screws
    });

  }, [jointAngles, isRobotReady, visMode]);

  // --- Visualization Helpers (Frames & Screws) ---
  useEffect(() => {
    if (!isRobotReady || !sceneRef.current || !robotRef.current) return;
    
    // Cleanup Frames
    if (framesRef.current) {
        framesRef.current.forEach(h => { if (h.parent) h.parent.remove(h); else sceneRef.current.remove(h); });
    }
    framesRef.current = [];

    // Cleanup Screws
    if (screwsRef.current) {
        screwsRef.current.forEach(h => sceneRef.current.remove(h));
    }
    screwsRef.current = [];

    const createFrame = (size = 1) => new THREE.AxesHelper(size);
    const createLabel = (text) => {
      const canvas = document.createElement('canvas');
      canvas.width = 128; canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.beginPath(); ctx.arc(64, 64, 40, 0, 2*Math.PI);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fill();
      ctx.font = 'bold 64px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = '#0f172a'; ctx.fillText(text, 64, 64);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, depthTest: false }));
      sprite.scale.set(0.8, 0.8, 0.8); sprite.renderOrder = 999;
      return sprite;
    };
    const createScrewArrow = (origin, dir, length, labelText) => {
        const hex = 0xff00ff; // Magenta for Screws
        const arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex, 0.4, 0.2);
        
        // Label
        const label = createLabel(labelText);
        label.position.copy(origin).add(dir.clone().multiplyScalar(length + 0.2));
        
        // Add dashed line for infinite axis implication
        const material = new THREE.LineDashedMaterial({ color: hex, dashSize: 0.2, gapSize: 0.1, opacity: 0.5, transparent: true });
        const points = [];
        points.push(origin.clone().add(dir.clone().multiplyScalar(-length))); // Backwards
        points.push(origin.clone().add(dir.clone().multiplyScalar(length * 2))); // Forwards
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        line.computeLineDistances();
        
        const group = new THREE.Group();
        group.add(arrowHelper);
        group.add(line);
        group.add(label);
        return group;
    };

    const { link1, link2, link3 } = robotRef.current;
    
    // MDH/SDH Frames
    if (visMode !== 'NONE') {
        const attach = (parent, frame, label, pos, rotY=0) => {
            frame.position.copy(pos);
            if (rotY) frame.rotation.y = rotY;
            label.position.copy(pos).add(new THREE.Vector3(0.4, 0.4, 0.4));
            parent.add(frame); parent.add(label);
            framesRef.current.push(frame, label);
        };

        const f0 = createFrame(1.5); const l0 = createLabel('{0}');
        const f1 = createFrame(1.2); const l1 = createLabel('{1}');
        const f2 = createFrame(1.2); const l2 = createLabel('{2}');
        const f3 = createFrame(1.2); const l3 = createLabel('{3}');

        if (visMode === 'MDH') {
          sceneRef.current.add(f0); sceneRef.current.add(l0); l0.position.set(0.4,0.4,0.4); framesRef.current.push(f0, l0);
          attach(link1, f1, l1, new THREE.Vector3(0,0,0));
          attach(link1, f2, l2, new THREE.Vector3(0, LINK_LENGTHS.L1, 0));
          attach(link2, f3, l3, new THREE.Vector3(LINK_LENGTHS.L2, 0, 0), Math.PI/2);
        } else if (visMode === 'SDH') {
          sceneRef.current.add(f0); sceneRef.current.add(l0); l0.position.set(0.4,0.4,0.4); framesRef.current.push(f0, l0);
          attach(link1, f1, l1, new THREE.Vector3(0, LINK_LENGTHS.L1, 0));
          attach(link2, f2, l2, new THREE.Vector3(LINK_LENGTHS.L2, 0, 0), Math.PI/2);
          attach(link3, f3, l3, new THREE.Vector3(0, LINK_LENGTHS.L3, 0));
        }
    } 
    // PoE Screws (Space Frame, Fixed)
    else {
        const baseOffset = 0.5;
        const s1 = createScrewArrow(new THREE.Vector3(0, baseOffset, 0), new THREE.Vector3(0, 1, 0), 3, 'S1');
        const s2 = createScrewArrow(new THREE.Vector3(0, baseOffset + LINK_LENGTHS.L1, 0), new THREE.Vector3(0, 0, 1), 2.5, 'S2');
        const s3 = createScrewArrow(new THREE.Vector3(LINK_LENGTHS.L2, baseOffset + LINK_LENGTHS.L1, 0), new THREE.Vector3(1, 0, 0), 2, 'S3');
        
        sceneRef.current.add(s1); sceneRef.current.add(s2); sceneRef.current.add(s3);
        screwsRef.current.push(s1, s2, s3);
    }

  }, [visMode, isRobotReady]); 

  const handleSlider = (axis, val) => setJointAngles(prev => ({ ...prev, [axis]: parseFloat(val) }));

  return (
    <div className="flex flex-col h-screen bg-gray-50 text-slate-800 font-sans overflow-hidden">
      <header className="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between shadow-sm z-10">
        <div className="flex items-center space-x-3">
          <div className="bg-blue-600 p-2 rounded-lg text-white"><Layers size={24} /></div>
          <h1 className="text-xl font-bold text-slate-800">机器人运动学建模教学</h1>
        </div>
        <div className="text-sm text-slate-500 hidden md:block">MDH vs SDH vs Screw Theory Visualization</div>
      </header>

      <div className="flex flex-1 overflow-hidden relative">
        {/* Left Sidebar */}
        <div className="w-full md:w-1/2 lg:w-5/12 border-r border-gray-200 bg-white flex flex-col z-10 shadow-lg">
           
           {/* Top: Tabs - Fixed */}
           <div className="flex border-b border-gray-200 bg-white z-10 shrink-0">
            {['intro', 'sdh', 'mdh', 'poe', 'compare'].map(tab => (
              <button key={tab} onClick={() => setActiveTab(tab)}
                className={`flex-1 py-3 text-sm font-medium border-b-2 transition-colors ${activeTab === tab ? 'border-blue-600 text-blue-600 bg-blue-50' : 'border-transparent text-slate-600 hover:bg-gray-50'}`}>
                {tab === 'intro' && '简介'}
                {tab === 'sdh' && 'SDH'}
                {tab === 'mdh' && 'MDH'}
                {tab === 'poe' && '旋量法'}
                {tab === 'compare' && '对比'}
              </button>
            ))}
          </div>

          {/* Middle: Scrollable Content */}
          <div className="flex-1 overflow-y-auto p-6 space-y-6">
            {activeTab === 'intro' && (
              <div className="space-y-4 animate-fadeIn">
                <h2 className="text-2xl font-bold text-slate-800">机械臂运动学基础</h2>
                <p className="leading-relaxed text-slate-600">
                  对于串联机械臂，运动学建模的核心目标是建立<strong>关节空间</strong>（Joint Space, <span>&theta;</span>）与<strong>笛卡尔空间</strong>（Cartesian Space, x,y,z,R）之间的数学映射。
                </p>
                <div className="bg-blue-50 p-4 rounded-lg border border-blue-100">
                  <h3 className="font-semibold text-blue-800 mb-2">本演示模型：3自由度正交关节机械臂</h3>
                  <ul className="list-disc list-inside text-sm text-blue-700 space-y-1">
                    <li>关节1 (Base): 绕 Z 轴旋转</li>
                    <li>关节2 (Shoulder): 绕 Y 轴旋转 (与 J1 正交)</li>
                    <li>关节3 (Elbow): 绕 X 轴旋转 (与 J2 正交)</li>
                  </ul>
                </div>
              </div>
            )}

            {activeTab === 'sdh' && (
              <div className="space-y-4 animate-fadeIn">
                <div className="flex justify-between items-center">
                  <h2 className="text-2xl font-bold text-slate-800">标准 DH (SDH)</h2>
                  <button onClick={() => setVisMode('SDH')} className={`px-3 py-1 rounded-full text-xs font-bold ${visMode === 'SDH' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700'}`}>
                    {visMode === 'SDH' ? '正在显示' : '切换至 SDH'}
                  </button>
                </div>
                <div className="prose prose-slate prose-sm">
                  <p>SDH (Standard DH) 核心特征是<strong>坐标系 i 固连在连杆 i 的远端</strong>。</p>
                  <h4 className="font-bold mt-4">变换顺序：</h4>
                  <p className="bg-gray-100 p-2 rounded font-mono text-xs">T = Rot_z(&theta;) · Trans_z(d) · Trans_x(a) · Rot_x(&alpha;)</p>
                  <ul className="list-disc pl-5 space-y-1 mt-2">
                    <li>Z<sub>i-1</sub> 轴：沿关节 i 的轴线。</li>
                    <li>X<sub>i</sub> 轴：沿公垂线方向。</li>
                  </ul>
                </div>
              </div>
            )}

            {activeTab === 'mdh' && (
              <div className="space-y-4 animate-fadeIn">
                <div className="flex justify-between items-center">
                  <h2 className="text-2xl font-bold text-slate-800">修正 DH (MDH)</h2>
                  <button onClick={() => setVisMode('MDH')} className={`px-3 py-1 rounded-full text-xs font-bold ${visMode === 'MDH' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700'}`}>
                    {visMode === 'MDH' ? '正在显示' : '切换至 MDH'}
                  </button>
                </div>
                <div className="prose prose-slate prose-sm">
                  <p>MDH (Craig's notation) 核心特征是<strong>坐标系 i 固连在连杆 i 的近端</strong>（与关节 i 重合）。</p>
                  <h4 className="font-bold mt-4">变换顺序：</h4>
                  <p className="bg-gray-100 p-2 rounded font-mono text-xs">T = Rot_x(&alpha;) · Trans_x(a) · Rot_z(&theta;) · Trans_z(d)</p>
                  <div className="bg-yellow-50 border-l-4 border-yellow-400 p-2 text-xs mt-2">
                    优点：能够完美处理树状分支结构，坐标系就在电机轴上。
                  </div>
                </div>
              </div>
            )}

            {activeTab === 'poe' && (
              <div className="space-y-4 animate-fadeIn">
                <div className="flex justify-between items-center">
                   <h2 className="text-2xl font-bold text-slate-800">旋量法 (PoE)</h2>
                   <button onClick={() => setVisMode('NONE')} className={`px-3 py-1 rounded-full text-xs font-bold ${visMode === 'NONE' ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-700'}`}>
                     {visMode === 'NONE' ? '正在显示' : '隐藏坐标系'}
                   </button>
                </div>
                <div className="prose prose-slate prose-sm">
                  <p>基于李群/李代数的指数积公式。只需要基座标系和零位参考位姿。</p>
                  <h4 className="font-bold mt-4">公式：</h4>
                  <div className="bg-slate-800 text-white p-3 rounded font-mono text-xs overflow-x-auto">
                    T(&theta;) = e^[S1]&theta;1 · ... · e^[Sn]&theta;n · M
                  </div>
                </div>
              </div>
            )}

            {activeTab === 'compare' && (
              <div className="space-y-4 animate-fadeIn">
                <h2 className="text-2xl font-bold text-slate-800">综合对比</h2>
                <div className="overflow-x-auto">
                  <table className="w-full text-sm text-left border-collapse">
                    <thead>
                      <tr className="bg-slate-100 border-b border-slate-200">
                        <th className="p-3 font-semibold">特性</th>
                        <th className="p-3 font-semibold">SDH</th>
                        <th className="p-3 font-semibold">MDH</th>
                        <th className="p-3 font-semibold">PoE</th>
                      </tr>
                    </thead>
                    <tbody className="divide-y divide-slate-100">
                      <tr>
                        <td className="p-3 font-medium text-slate-700">坐标系</td>
                        <td className="p-3">连杆远端</td>
                        <td className="p-3 text-green-600">连杆近端</td>
                        <td className="p-3 text-blue-600">全局基座</td>
                      </tr>
                      <tr>
                        <td className="p-3 font-medium text-slate-700">奇异性</td>
                        <td className="p-3">存在</td>
                        <td className="p-3">存在</td>
                        <td className="p-3 text-green-600 font-bold">无</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            )}
          </div>

          {/* Bottom: Real-time Status Area - Fixed at bottom of sidebar */}
          <div className="border-t border-gray-200 bg-slate-50 p-4 shrink-0 overflow-y-auto max-h-[45vh]">
             <div className="flex items-center gap-2 mb-3">
                <Activity size={16} className="text-blue-600"/>
                <span className="text-sm font-bold text-slate-800">实时运动学状态</span>
             </div>
             
             <div className="space-y-4">
                {/* End Effector State */}
                <div>
                    <div className="text-xs font-bold text-slate-500 mb-2 flex items-center gap-1"><Move3d size={12}/> 末端位姿 (World)</div>
                    <div className="grid grid-cols-2 gap-2 text-[10px] font-mono bg-white p-2 rounded border border-slate-200 shadow-sm">
                        <div className="space-y-1">
                            <div className="text-slate-400">Position</div>
                            <div>X: {f(kinematicsData.endEffector.pos.x)}</div>
                            <div>Y: {f(kinematicsData.endEffector.pos.y)}</div>
                            <div>Z: {f(kinematicsData.endEffector.pos.z)}</div>
                        </div>
                        <div className="space-y-1">
                            <div className="text-slate-400">Euler (RPY)</div>
                            <div>R: {f(kinematicsData.endEffector.rot.x)}</div>
                            <div>P: {f(kinematicsData.endEffector.rot.y)}</div>
                            <div>Y: {f(kinematicsData.endEffector.rot.z)}</div>
                        </div>
                    </div>
                </div>

                {/* Conditional Display */}
                {(visMode === 'MDH' || visMode === 'SDH') && (
                    <div className="animate-fadeIn">
                        <div className="text-xs font-bold text-slate-500 mb-2 flex items-center gap-1"><ArrowRightLeft size={12}/> 转换矩阵 ({visMode})</div>
                        {kinematicsData.matrices.length > 0 ? (
                            kinematicsData.matrices.map((m, i) => (
                                <MatrixDisplay key={i} matrix={m.data} label={m.name} />
                            ))
                        ) : (
                            <div className="text-xs text-slate-400 italic">正在初始化坐标系...</div>
                        )}
                    </div>
                )}

                {visMode === 'NONE' && (
                    <div className="animate-fadeIn">
                         <div className="text-xs font-bold text-slate-500 mb-2 flex items-center gap-1"><Activity size={12}/> 运动旋量 (PoE)</div>
                         {kinematicsData.poeScrews.map((s, i) => (
                             <ScrewDisplay key={i} {...s} />
                         ))}
                    </div>
                )}
             </div>
          </div>
        </div>

        {/* 3D View */}
        <div className="flex-1 relative bg-slate-100">
          <div ref={mountRef} className="w-full h-full cursor-move" />
          
          {/* Controls Overlay (Bottom Center) */}
          <div className="absolute bottom-4 left-4 right-4 md:right-auto md:w-80 bg-white/90 backdrop-blur p-4 rounded-xl shadow-lg border border-gray-200">
             <div className="flex items-center gap-2 mb-3 text-sm font-bold text-slate-700"><RefreshCw size={16}/> 关节控制 (rad)</div>
             {[
               { id: 'j1', label: 'J1 (Base/Z)', min: -Math.PI, max: Math.PI },
               { id: 'j2', label: 'J2 (Link1/Y)', min: -Math.PI/2, max: Math.PI/2 },
               { id: 'j3', label: 'J3 (Link2/X)', min: -Math.PI/2, max: Math.PI/2 }
             ].map(j => (
               <div key={j.id} className="mb-2">
                 <div className="flex justify-between text-xs mb-1"><span>{j.label}</span><span>{f(jointAngles[j.id])}</span></div>
                 <input type="range" min={j.min} max={j.max} step={0.01} value={jointAngles[j.id]} onChange={e=>handleSlider(j.id, e.target.value)} className="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600"/>
               </div>
             ))}
          </div>
        </div>
      </div>
    </div>
  );
};

export default App;
